@page "/EditHeya"

@attribute [Authorize]

@using Data;

@implements IAsyncDisposable

@inject Microsoft.AspNetCore.Identity.SignInManager<Data.ApplicationUser> SignInManager
@inject NavigationManager _navigationManager
@inject IJSRuntime JSRuntime

<h3>EditHeya</h3>

<table class="table table-bordered table-responsive">
    <tbody>
        @for(int y=0; y<10; y++)
        {
            var captureY = y;

            <tr class="row">
                @for(int x=0; x<10; x++)
                {
                    var captureX = x;

                    <td class="column">
                        <div class="box" @onclick="BoxTemplate[captureY][captureX].OnClickBox" draggable="true" @ondragstart="BoxTemplate[captureY][captureX].OnDragStartBox" @ondrag="OnDragTableCell" @ondragend="OnDragEndTableCell">
                            <div class="top" hidden="@HiddenEdge(captureX, captureY, HeyaStructEdgeType.Top)" draggable="true" @ondragstart="BoxTemplate[captureY][captureX].OnDragStartEdgeTop" @ondragstart:stopPropagation="true"></div>
                            <div class="bottom" hidden="@HiddenEdge(captureX, captureY, HeyaStructEdgeType.Bottom)" draggable="true" @ondragstart="BoxTemplate[captureY][captureX].OnDragStartEdgeBottom" @ondragstart:stopPropagation="true"></div>
                            <div class="left" hidden="@HiddenEdge(captureX, captureY, HeyaStructEdgeType.Left)" draggable="true" @ondragstart="BoxTemplate[captureY][captureX].OnDragStartEdgeLeft" @ondragstart:stopPropagation="true"></div>
                            <div class="right" hidden="@HiddenEdge(captureX, captureY, HeyaStructEdgeType.Right)" draggable="true" @ondragstart="BoxTemplate[captureY][captureX].OnDragStartEdgeRight" @ondragstart:stopPropagation="true"></div>
                            <div class="@GetVertexAttribute(captureX, captureY, HeyaStructVertexType.TopLeft)" hidden="@HiddenVertex(captureX, captureY, HeyaStructVertexType.TopLeft)" draggable="true" @ondragstart="BoxTemplate[captureY][captureX].OnDragStartVertexTopLeft" @ondragstart:stopPropagation="true"></div>
                            <div class="@GetVertexAttribute(captureX, captureY, HeyaStructVertexType.TopRight)" hidden="@HiddenVertex(captureX, captureY, HeyaStructVertexType.TopRight)" draggable="true" @ondragstart="BoxTemplate[captureY][captureX].OnDragStartVertexTopRight" @ondragstart:stopPropagation="true"></div>
                            <div class="@GetVertexAttribute(captureX, captureY, HeyaStructVertexType.BottomLeft)" hidden="@HiddenVertex(captureX, captureY, HeyaStructVertexType.BottomLeft)" draggable="true" @ondragstart="BoxTemplate[captureY][captureX].OnDragStartVertexBottomLeft" @ondragstart:stopPropagation="true"></div>
                            <div class="@GetVertexAttribute(captureX, captureY, HeyaStructVertexType.BottomRight)" hidden="@HiddenVertex(captureX, captureY, HeyaStructVertexType.BottomRight)" draggable="true" @ondragstart="BoxTemplate[captureY][captureX].OnDragStartVertexBottomRight" @ondragstart:stopPropagation="true"></div>
                        </div>
                    </td>
                }
            </tr>
        }
    </tbody>
</table>

<button @onclick="OnClickSaveButton">Save</button>

@code {
    private enum DragModeType
    {
        None,
        Move,
        ResizeTop,
        ResizeBottom,
        ResizeLeft,
        ResizeRight,
        ResizeTopLeftCross,
        ResizeTopRightCross,
        ResizeBottomLeftCross,
        ResizeBottomRightCross,
    }

    private class Box
    {
        public Action<MouseEventArgs> OnClickBox { get; set; } = (e) => { };
        public Action<DragEventArgs> OnDragStartBox { get; set; } = (e) => { };
        public Action<DragEventArgs> OnDragStartEdgeTop { get; set; } = (e) => { };
        public Action<DragEventArgs> OnDragStartEdgeBottom { get; set; } = (e) => { };
        public Action<DragEventArgs> OnDragStartEdgeLeft { get; set; } = (e) => { };
        public Action<DragEventArgs> OnDragStartEdgeRight { get; set; } = (e) => { };
        public Action<DragEventArgs> OnDragStartVertexTopLeft { get; set; } = (e) => { };
        public Action<DragEventArgs> OnDragStartVertexTopRight { get; set; } = (e) => { };
        public Action<DragEventArgs> OnDragStartVertexBottomLeft { get; set; } = (e) => { };
        public Action<DragEventArgs> OnDragStartVertexBottomRight { get; set; } = (e) => { };
    }

    private string? UserId { get; set; }
    private Box[][] BoxTemplate { get; set; } = new Box[10][];
    private List<Heya> Heyas { get; set; } = new List<Heya>();
    private DragModeType CurrentDragModeType { get; set; }
    private Heya? CurrentDragHeya { get; set; }
    private IJSObjectReference? JavaScriptModule { get; set; }
    private int TableWidth { get; set; }
    private int TableHeight { get; set; }
    private int TableOffsetLeft { get; set; }
    private int TableOffsetTop { get; set; }

    protected override void OnInitialized()
    {
        // デリゲートの再生成を回避するために初期化処理の時点で定義する (イベントコールバックに直接ラムダ式を書くと部屋のドラッグ動作が重くなるので避ける)
        for (int y = 0; y < 10; y++)
        {
            var captureY = y;

            BoxTemplate[captureY] = new Box[10];

            for (int x = 0; x < 10; x++)
            {
                var captureX = x;

                BoxTemplate[y][x] = new Box();

                BoxTemplate[y][x].OnClickBox = (e) => { OnClickTableCell(captureX, captureY); };
                BoxTemplate[y][x].OnDragStartBox = async (e) => { await OnDragStartTableCellMove(captureX, captureY); };
                BoxTemplate[y][x].OnDragStartEdgeTop = async (e) => { await OnDragStartTableCellResizeTop(captureX, captureY); };
                BoxTemplate[y][x].OnDragStartEdgeBottom = async (e) => { await OnDragStartTableCellResizeBottom(captureX, captureY); };
                BoxTemplate[y][x].OnDragStartEdgeLeft = async (e) => { await OnDragStartTableCellResizeLeft(captureX, captureY); };
                BoxTemplate[y][x].OnDragStartEdgeRight = async (e) => { await OnDragStartTableCellResizeRight(captureX, captureY); };
                BoxTemplate[y][x].OnDragStartVertexTopLeft = async (e) => { await GetVertexDragStartMethod(captureX, captureY, HeyaStructVertexType.TopLeft); };
                BoxTemplate[y][x].OnDragStartVertexTopRight = async (e) => { await GetVertexDragStartMethod(captureX, captureY, HeyaStructVertexType.TopRight); };
                BoxTemplate[y][x].OnDragStartVertexBottomLeft = async (e) => { await GetVertexDragStartMethod(captureX, captureY, HeyaStructVertexType.BottomLeft); };
                BoxTemplate[y][x].OnDragStartVertexBottomRight = async (e) => { await GetVertexDragStartMethod(captureX, captureY, HeyaStructVertexType.BottomRight); };
            }
        }

        base.OnInitialized();
    }

    protected override async Task OnInitializedAsync()
    {
        var user = await SignInManager.UserManager.GetUserAsync(SignInManager.Context.User);

        UserId = user.UserId.ToString();

        using var applicationDbContext = new ApplicationDbContext();

        Heyas = applicationDbContext.Heyas!.Where(heya => heya.Owner == UserId).ToList();

        await base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            JavaScriptModule = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/EditHeya.js");

            TableOffsetLeft = await JavaScriptModule!.InvokeAsync<int>("getTableElementOffsetLeft");
            TableOffsetTop = await JavaScriptModule!.InvokeAsync<int>("getTableElementOffsetTop");
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private bool HiddenEdge(int x, int y, HeyaStructEdgeType edgeType)
    {
        return !TableUtility.ExistEdge(Heyas, x, y, edgeType);
    }

    private bool HiddenVertex(int x, int y, HeyaStructVertexType vertexType)
    {
        return !TableUtility.ExistVertex(Heyas, x, y, vertexType);
    }

    private string GetVertexAttribute(int x, int y, HeyaStructVertexType vertexType)
    {
        switch (TableUtility.GetVertexCrossType(Heyas, x, y, vertexType))
        {
            case HeyaStructVertexCrossType.None: return "";
            case HeyaStructVertexCrossType.TopLeftTop: return "top-left-direction-top";
            case HeyaStructVertexCrossType.TopLeftLeft: return "top-left-direction-left";
            case HeyaStructVertexCrossType.TopLeftCross: return "top-left-direction-cross";
            case HeyaStructVertexCrossType.TopRightTop: return "top-right-direction-top";
            case HeyaStructVertexCrossType.TopRightRight: return "top-right-direction-right";
            case HeyaStructVertexCrossType.TopRightCross: return "top-right-direction-cross";
            case HeyaStructVertexCrossType.BottomLeftBottom: return "bottom-left-direction-bottom";
            case HeyaStructVertexCrossType.BottomLeftLeft: return "bottom-left-direction-left";
            case HeyaStructVertexCrossType.BottomLeftCross: return "bottom-left-direction-cross";
            case HeyaStructVertexCrossType.BottomRightBottom: return "bottom-right-direction-bottom";
            case HeyaStructVertexCrossType.BottomRightRight: return "bottom-right-direction-right";
            case HeyaStructVertexCrossType.BottomRightCross: return "bottom-right-direction-cross";
        }

        return "";
    }

    private async Task GetVertexDragStartMethod(int x, int y, HeyaStructVertexType vertexType)
    {
        switch (TableUtility.GetVertexCrossType(Heyas, x, y, vertexType))
        {
            case HeyaStructVertexCrossType.TopLeftTop: await OnDragStartTableCellResizeTop(x, y); break;
            case HeyaStructVertexCrossType.TopLeftLeft: await OnDragStartTableCellResizeLeft(x, y); break;
            case HeyaStructVertexCrossType.TopLeftCross: await OnDragStartTableCellResizeTopLeftCross(x, y); break;
            case HeyaStructVertexCrossType.TopRightTop: await OnDragStartTableCellResizeTop(x, y); break;
            case HeyaStructVertexCrossType.TopRightRight: await OnDragStartTableCellResizeRight(x, y); break;
            case HeyaStructVertexCrossType.TopRightCross: await OnDragStartTableCellResizeTopRightCross(x, y); break;
            case HeyaStructVertexCrossType.BottomLeftBottom: await OnDragStartTableCellResizeBottom(x, y); break;
            case HeyaStructVertexCrossType.BottomLeftLeft: await OnDragStartTableCellResizeLeft(x, y); break;
            case HeyaStructVertexCrossType.BottomLeftCross: await OnDragStartTableCellResizeBottomLeftCross(x, y); break;
            case HeyaStructVertexCrossType.BottomRightBottom: await OnDragStartTableCellResizeBottom(x, y); break;
            case HeyaStructVertexCrossType.BottomRightRight: await OnDragStartTableCellResizeRight(x, y); break;
            case HeyaStructVertexCrossType.BottomRightCross: await OnDragStartTableCellResizeBottomRightCross(x, y); break;
        }
    }

    private void OnClickTableCell(int x, int y)
    {
        Heyas.Add(new Heya() { Id = Guid.NewGuid(), Owner = UserId, Name = "", X = x, Y = y, Width = 1, Height = 1 });
    }

    private void OnDragTableCell(DragEventArgs e)
    {
        if (CurrentDragHeya == null)
        {
            return;
        }

        switch (CurrentDragModeType)
        {
            case DragModeType.Move:
                OnDragTableCellMove(e);
                break;

            case DragModeType.ResizeTop:
                OnDragTableCellResizeTop(e);
                break;

            case DragModeType.ResizeBottom:
                OnDragTableCellResizeBottom(e);
                break;

            case DragModeType.ResizeLeft:
                OnDragTableCellResizeLeft(e);
                break;

            case DragModeType.ResizeRight:
                OnDragTableCellResizeRight(e);
                break;

            case DragModeType.ResizeTopLeftCross:
                OnDragTableCellResizeTopLeftCross(e);
                break;

            case DragModeType.ResizeTopRightCross:
                OnDragTableCellResizeTopRightCross(e);
                break;

            case DragModeType.ResizeBottomLeftCross:
                OnDragTableCellResizeBottomLeftCross(e);
                break;

            case DragModeType.ResizeBottomRightCross:
                OnDragTableCellResizeBottomRightCross(e);
                break;
        }
    }

    private async Task OnDragStartTableCell(int x, int y, DragModeType dragModeType)
    {
        CurrentDragHeya = Heyas.SingleOrDefault(heya => ((heya.X <= x) && (x < heya.X + heya.Width) && (heya.Y <= y) && (y < heya.Y + heya.Height)));

        CurrentDragModeType = dragModeType;

        TableWidth = await JavaScriptModule!.InvokeAsync<int>("getTableElementWidth");
        TableHeight = await JavaScriptModule!.InvokeAsync<int>("getTableElementHeight");
    }

    private async Task OnDragStartTableCellMove(int x, int y)
    {
        await OnDragStartTableCell(x, y, DragModeType.Move);
    }

    private bool IsEnablePageValue(double pageX, double pageY)
    {
        int x = (int)pageX;
        int y = (int)pageY;

        return ((pageX != 0) || (pageY != 0));
    }

    private void OnDragTableCellMove(DragEventArgs e)
    {
        if (!IsEnablePageValue(e.PageX, e.PageY))
        {
            return;
        }

        int x = (int)((e.PageX - TableOffsetLeft) / (TableWidth / 10));
        int y = (int)((e.PageY - TableOffsetTop) / (TableHeight / 10));

        if (x >= 0)
        {
            CurrentDragHeya!.X = x;
        }

        if (y >= 0)
        {
            CurrentDragHeya!.Y = y;
        }
    }

    private void OnDragEndTableCell()
    {
        CurrentDragHeya = null;

        CurrentDragModeType = DragModeType.None;
    }

    private async Task OnDragStartTableCellResizeTop(int x, int y)
    {
        await OnDragStartTableCell(x, y, DragModeType.ResizeTop);
    }

    private async Task OnDragStartTableCellResizeBottom(int x, int y)
    {
        await OnDragStartTableCell(x, y, DragModeType.ResizeBottom);
    }

    private async Task OnDragStartTableCellResizeLeft(int x, int y)
    {
        await OnDragStartTableCell(x, y, DragModeType.ResizeLeft);
    }

    private async Task OnDragStartTableCellResizeRight(int x, int y)
    {
        await OnDragStartTableCell(x, y, DragModeType.ResizeRight);
    }

    private async Task OnDragStartTableCellResizeTopLeftCross(int x, int y)
    {
        await OnDragStartTableCell(x, y, DragModeType.ResizeTopLeftCross);
    }

    private async Task OnDragStartTableCellResizeTopRightCross(int x, int y)
    {
        await OnDragStartTableCell(x, y, DragModeType.ResizeTopRightCross);
    }

    private async Task OnDragStartTableCellResizeBottomLeftCross(int x, int y)
    {
        await OnDragStartTableCell(x, y, DragModeType.ResizeBottomLeftCross);
    }

    private async Task OnDragStartTableCellResizeBottomRightCross(int x, int y)
    {
        await OnDragStartTableCell(x, y, DragModeType.ResizeBottomRightCross);
    }

    private void OnDragTableCellResizeLeft(DragEventArgs e)
    {
        if (!IsEnablePageValue(e.PageX, e.PageY))
        {
            return;
        }

        var x = (int)((e.PageX - TableOffsetLeft) / (TableWidth / 10));

        if (x != CurrentDragHeya!.X)
        {
            var width = CurrentDragHeya.Width + (CurrentDragHeya.X - x);

            if (width > 0)
            {
                CurrentDragHeya.Width = width;
                CurrentDragHeya.X = x;
            }
        }
    }

    private void OnDragTableCellResizeRight(DragEventArgs e)
    {
        if (!IsEnablePageValue(e.PageX, e.PageY))
        {
            return;
        }

        var x = (int)((e.PageX - TableOffsetLeft) / (TableWidth / 10));

        if (x != CurrentDragHeya!.X)
        {
            var width = (x - CurrentDragHeya.X);

            if (width > 0)
            {
                CurrentDragHeya.Width = width;
            }
        }
    }

    private void OnDragTableCellResizeTop(DragEventArgs e)
    {
        if (!IsEnablePageValue(e.PageX, e.PageY))
        {
            return;
        }

        var y = (int)((e.PageY - TableOffsetTop) / (TableHeight / 10));

        if (y != CurrentDragHeya!.Y)
        {
            var height = CurrentDragHeya.Height + (CurrentDragHeya.Y - y);

            if (height > 0)
            {
                CurrentDragHeya.Height = height;
                CurrentDragHeya.Y = y;
            }
        }
    }

    private void OnDragTableCellResizeBottom(DragEventArgs e)
    {
        if (!IsEnablePageValue(e.PageX, e.PageY))
        {
            return;
        }

        var y = (int)((e.PageY - TableOffsetTop) / (TableHeight / 10));

        if (y != CurrentDragHeya!.Y)
        {
            var height = (y - CurrentDragHeya.Y);

            if (height > 0)
            {
                CurrentDragHeya.Height = height;
            }
        }
    }

    private void OnDragTableCellResizeTopLeftCross(DragEventArgs e)
    {
        OnDragTableCellResizeLeft(e);
        OnDragTableCellResizeTop(e);
    }

    private void OnDragTableCellResizeTopRightCross(DragEventArgs e)
    {
        OnDragTableCellResizeRight(e);
        OnDragTableCellResizeTop(e);
    }

    private void OnDragTableCellResizeBottomLeftCross(DragEventArgs e)
    {
        OnDragTableCellResizeLeft(e);
        OnDragTableCellResizeBottom(e);
    }

    private void OnDragTableCellResizeBottomRightCross(DragEventArgs e)
    {
        OnDragTableCellResizeRight(e);
        OnDragTableCellResizeBottom(e);
    }

    private void OnClickSaveButton()
    {
        _navigationManager.NavigateTo($"/{UserId}");
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (JavaScriptModule is not null)
        {
            await JavaScriptModule.DisposeAsync();
        }
    }
}
